<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Retro Interactive Snake Game with CRT Shader</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");
      body {
        background: #000;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 1rem;
        font-family: "Press Start 2P", monospace;
        color: #39ff14;
        text-shadow: 0 0 6px #39ff14;
        margin: 0;
      }
      canvas {
        image-rendering: pixelated;
        display: block;
        border-radius: 0;
      }
      .game-over-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #f00;
        font-weight: 700;
        font-size: 1.5rem;
        pointer-events: none;
        -webkit-user-select: none;
        user-select: none;
        text-shadow: 0 0 8px #f00;
        font-family: "Press Start 2P", monospace;
        z-index: 10;
        text-align: center;
        line-height: 1.2;
        white-space: nowrap;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      }
      .ui-container {
        margin-top: 1rem;
        width: 400px;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }
      #score {
        font-size: 1rem;
        font-weight: 700;
        color: #39ff14;
        text-shadow: 0 0 6px #39ff14;
        flex-shrink: 0;
      }
      .btn-text {
        background: none;
        border: none;
        color: #f0a;
        font-family: "Press Start 2P", monospace;
        font-size: 0.85rem;
        padding: 0 0.2rem;
        font-weight: 700;
        cursor: pointer;
        box-shadow: none;
        text-shadow: 0 0 2px #f0a;
        border-radius: 0;
        outline: none;
        margin: 0;
        transition: color 0.15s;
      }
      .btn-text:hover {
        color: #fff;
        text-shadow: 0 0 6px #fff;
      }
      .btn-group {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        align-items: center;
      }
      .relative {
        position: relative;
        width: 400px;
        height: 400px;
      }
      #webglCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        background: transparent;
      }
      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 400px;
        height: 400px;
        border: 4px solid #39ff14;
        image-rendering: pixelated;
        background: transparent;
        box-shadow: 0 0 10px #39ff14;
        border-radius: 0;
        z-index: 1;
        transform-origin: center center;
        transform: scale(1) skewX(0.03rad) skewY(0.02rad);
        display: none;
      }
      .controls-hint {
        margin-top: 1rem;
        font-size: 0.7rem;
        color: #39ff14;
        text-shadow: 0 0 4px #39ff14;
        text-align: center;
        opacity: 0.8;
      }
      .hidden {
        display: none;
      }
      .keyboard-shortcuts {
        position: fixed;
        bottom: 20px;
        right: 20px;
        font-family: "Press Start 2P", monospace;
        color: #39ff14;
        text-shadow: 0 0 4px #39ff14;
        z-index: 100;
        min-width: 200px;
      }
      .keyboard-shortcuts ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .keyboard-shortcuts li {
        margin: 8px 0;
        font-size: 0.6rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .key {
        display: inline-block;
        background: #000;
        border: 1px solid #39ff14;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 0.5rem;
        min-width: 20px;
        text-align: center;
        box-shadow: 0 0 4px #39ff14;
        color: #39ff14;
        text-shadow: 0 0 2px #39ff14;
      }
      .key-group {
        display: flex;
        gap: 2px;
      }
    </style>
  </head>
  <body>
    <div class="relative">
      <canvas id="gameCanvas" width="400" height="400"></canvas>
      <canvas id="webglCanvas" width="400" height="400"></canvas>
      <div id="gameOverText" class="game-over-overlay hidden">GAME OVER</div>
    </div>
    <div class="ui-container">
      <div id="score">SCORE: 0</div>
      <div class="btn-group">
        <button id="muteBtn" class="btn-text" aria-label="Mute/Unmute Sound">
          MUTE
        </button>
        <button id="resetBtn" class="btn-text">RESET</button>
      </div>
    </div>
    <div class="controls-hint">
      USE ARROW KEYS TO MOVE
    </div>
    <div class="keyboard-shortcuts">
      <ul>
        <li>
          <span>MOVE:</span>
          <div class="key-group">
            <span class="key">↑</span>
            <span class="key">↓</span>
            <span class="key">←</span>
            <span class="key">→</span>
          </div>
        </li>
        <li>
          <span>RESET:</span>
          <span class="key">R</span>
        </li>
        <li>
          <span>MUTE:</span>
          <span class="key">M</span>
        </li>
      </ul>
    </div>
    <script>
      const gameCanvas = document.getElementById("gameCanvas"),
        ctx = gameCanvas.getContext("2d"),
        webglCanvas = document.getElementById("webglCanvas"),
        gl = webglCanvas.getContext("webgl"),
        gameOverText = document.getElementById("gameOverText"),
        scoreDisplay = document.getElementById("score"),
        resetBtn = document.getElementById("resetBtn"),
        muteBtn = document.getElementById("muteBtn"),
        gridSize = 20,
        cols = gameCanvas.width / gridSize,
        rows = gameCanvas.height / gridSize;
      
      let snake = [{ x: 10, y: 10 }],
        direction = { x: 1, y: 0 },
        nextDirection = { x: 1, y: 0 }, // Buffer for next direction
        food = { x: 5, y: 5 },
        gameOver = false,
        score = 0,
        soundMuted = false,
        audioCtx = null,
        gameRunning = false,
        gameSpeed = 150; // Slower speed for better control

      // Set initial button text
      muteBtn.textContent = "MUTE";

      // Particle system for food burst
      let particles = [];
      function spawnParticles(x, y) {
        const n = 24;
        for (let i = 0; i < n; i++) {
          const angle = (Math.PI * 2 * i) / n + (Math.random() - 0.5) * 0.2;
          const speed = 2 + Math.random() * 1.8;
          particles.push({
            x: x + gridSize / 2,
            y: y + gridSize / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            alpha: 1,
            radius: 2 + Math.random() * 2,
            color: "#ff00ff",
            life: 0,
            maxLife: 16 + Math.floor(Math.random() * 8),
          });
        }
      }
      
      function updateParticles() {
        for (let p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.life++;
          p.alpha = 1 - p.life / p.maxLife;
        }
        particles = particles.filter((p) => p.life < p.maxLife);
      }
      
      function drawParticles() {
        for (let p of particles) {
          ctx.save();
          ctx.globalAlpha = Math.max(0, p.alpha * 0.75);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 12;
          ctx.fill();
          ctx.restore();
        }
      }

      function playBeep() {
        if (soundMuted) return;
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const duration = 0.13,
          startFreq = 380,
          endFreq = 320,
          attack = 0.01,
          decay = 0.08;
        const now = audioCtx.currentTime;
        const o = audioCtx.createOscillator(),
          g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(startFreq, now);
        o.frequency.linearRampToValueAtTime(endFreq, now + duration);
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.15, now + attack);
        g.gain.linearRampToValueAtTime(0.1, now + decay);
        g.gain.linearRampToValueAtTime(0, now + duration);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(now);
        o.stop(now + duration);
        o.onended = () => {
          o.disconnect();
          g.disconnect();
        };
      }
      
      function draw() {
        // Fill background green inside the canvas
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#002b0a"; // Deep green background
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.restore();
        
        // Draw food first
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#ff00ff";
        ctx.shadowColor = "#ff00ff";
        ctx.shadowBlur = 15;
        ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // Draw particles UNDER the snake
        drawParticles();
        
        // Draw snake head
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#39ff14";
        ctx.shadowColor = "#39ff14";
        ctx.shadowBlur = 10;
        ctx.fillRect(
          snake[0].x * gridSize,
          snake[0].y * gridSize,
          gridSize,
          gridSize
        );
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // Draw snake body
        for (let i = 1; i < snake.length; i++) {
          ctx.save();
          ctx.globalAlpha = 0.45; // Less opaque for snake body
          ctx.fillStyle = "#00ff00";
          ctx.shadowColor = "#39ff14";
          ctx.shadowBlur = 10;
          ctx.fillRect(
            snake[i].x * gridSize,
            snake[i].y * gridSize,
            gridSize,
            gridSize
          );
          ctx.shadowBlur = 0;
          ctx.restore();
        }
        
        if (gameOver) {
          gameOverText.classList.remove("hidden");
        } else {
          gameOverText.classList.add("hidden");
        }
      }
      
      function placeFood() {
        let validPositions = [];
        for (let x = 0; x < cols; x++) {
          for (let y = 0; y < rows; y++) {
            if (!snake.some((seg) => seg.x === x && seg.y === y)) {
              validPositions.push({ x, y });
            }
          }
        }
        if (validPositions.length === 0) {
          gameOver = true;
          return;
        }
        food = validPositions[Math.floor(Math.random() * validPositions.length)];
      }
      
      function collidesWithSnake(pos) {
        return snake.some(
          (segment) => segment.x === pos.x && segment.y === pos.y
        );
      }
      
      function insideGrid(pos) {
        return pos.x >= 0 && pos.x < cols && pos.y >= 0 && pos.y < rows;
      }
      
      function update() {
        if (gameOver) return;
        
        // Update direction from buffered input
        direction = { ...nextDirection };
        
        const newHead = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y,
        };
        
        if (!insideGrid(newHead) || collidesWithSnake(newHead)) {
          gameOver = true;
          return;
        }
        
        snake.unshift(newHead);
        
        if (newHead.x === food.x && newHead.y === food.y) {
          spawnParticles(food.x * gridSize, food.y * gridSize);
          placeFood();
          score++;
          scoreDisplay.textContent = "SCORE: " + score;
          playBeep();
          
          // Increase speed slightly as score increases
          gameSpeed = Math.max(80, 150 - Math.floor(score / 5) * 5);
        } else {
          snake.pop();
        }
        
        updateParticles();
      }
      
      // Keyboard input handling
      function handleKeyPress(event) {
        const key = event.key.toLowerCase();
        
        // Handle game controls
        if (!gameOver) {
          const currentDir = { ...direction };
          
          // Prevent 180-degree turns
          switch (key) {
            case 'arrowup':
              if (currentDir.y !== 1) {
                nextDirection = { x: 0, y: 1 };
              }
              break;
            case 'arrowdown':
              if (currentDir.y !== -1) {
                nextDirection = { x: 0, y: -1 };
              }
              break;
            case 'arrowleft':
              if (currentDir.x !== 1) {
                nextDirection = { x: -1, y: 0 };
              }
              break;
            case 'arrowright':
              if (currentDir.x !== -1) {
                nextDirection = { x: 1, y: 0 };
              }
              break;
          }
          
          // Start the game on first movement key press
          if (!gameRunning && (key === 'arrowup' || key === 'arrowdown' || key === 'arrowleft' || key === 'arrowright')) {
            gameRunning = true;
            gameLoop();
          }
        }
        
        // Handle global shortcuts
        switch (key) {
          case 'r':
            resetGame();
            break;
          case 'm':
            soundMuted = !soundMuted;
            muteBtn.textContent = soundMuted ? "MUTED" : "MUTE";
            break;
        }
      }
      
      // Add keyboard event listeners
      document.addEventListener('keydown', handleKeyPress);
      
      const vertexShaderSource = "attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;void main(){gl_Position=vec4(a_position,0,1);v_texCoord=a_texCoord;}",
        fragmentShaderSource = "precision mediump float;varying vec2 v_texCoord;uniform sampler2D u_texture;const float curvature=0.1;const float scanlineIntensity=0.25;const float vignetteIntensity=0.4;const float noiseIntensity=0.03;const vec3 greenTint=vec3(0.65,1.0,0.65);float rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233)))*43758.5453);}void main(){vec2 uv=v_texCoord*2.0-1.0;float r=length(uv);uv*=1.0+curvature*r*r;uv=(uv+1.0)/2.0;if(uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0){gl_FragColor=vec4(0.02,0.12,0.05,1);return;}vec4 color=texture2D(u_texture,uv);float scanline=sin(v_texCoord.y*800.0)*scanlineIntensity;color.rgb-=scanline;float vig=smoothstep(0.8,0.5,length(v_texCoord-0.5));color.rgb*=mix(1.0,vig,vignetteIntensity);float noise=rand(v_texCoord*1000.0)*noiseIntensity;color.rgb+=noise;color.rgb*=greenTint;gl_FragColor=color;}";
      
      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          return shader;
        }
        console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      
      function createProgram(vertexSource, fragmentSource) {
        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
          return program;
        }
        console.error("Program link failed:", gl.getProgramInfoLog(program));
        return null;
      }
      
      const program = createProgram(vertexShaderSource, fragmentShaderSource);
      const vertices = new Float32Array([
        -1, -1, 0, 0,
        1, -1, 1, 0,
        -1, 1, 0, 1,
        1, 1, 1, 1,
      ]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      
      const a_position = gl.getAttribLocation(program, "a_position");
      const a_texCoord = gl.getAttribLocation(program, "a_texCoord");
      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(a_texCoord);
      gl.vertexAttribPointer(a_texCoord, 2, gl.FLOAT, false, 16, 8);
      
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      
      gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);
      
      function renderWebGL() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          gameCanvas
        );
        const u_texture = gl.getUniformLocation(program, "u_texture");
        gl.uniform1i(u_texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
      
      function gameLoop() {
        if (!gameRunning || gameOver) return;
        
        update();
        draw();
        renderWebGL();
        
        setTimeout(gameLoop, gameSpeed);
      }
      
      function resetGame() {
        snake = [{ x: 10, y: 10 }];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        score = 0;
        gameSpeed = 150;
        scoreDisplay.textContent = "SCORE: " + score;
        gameOver = false;
        gameRunning = false;
        particles = [];
        placeFood();
        
        // Draw initial state
        draw();
        renderWebGL();
      }
      
      resetBtn.addEventListener("click", resetGame);
      muteBtn.addEventListener("click", () => {
        soundMuted = !soundMuted;
        muteBtn.textContent = soundMuted ? "MUTED" : "MUTE";
      });
      
      // Initialize the game
      placeFood();
      draw();
      renderWebGL();
    </script>
  </body>
</html> 